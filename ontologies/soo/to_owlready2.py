import glob
import os.path
import pathlib
import pprint
import shutil
from collections import defaultdict

from owlready2 import Ontology, ObjectPropertyClass, ThingClass, onto_path, get_ontology
from pandas._typing import FilePath
_this_folder = os.path.abspath(os.path.dirname(__file__))
_owl_filename = os.path.join(_this_folder, "soo.owl")
_owl_iri = "http://www.ontosynthesis.org/SOO"
_tag_class = "owl:Class" 
_tag_object_property = "owl:ObjectProperty"
_tag_rdfs_label = 'rdfs:label'
_tag_skos_definition = 'skos:definition'

_OWLREADY2_HEADER = f"""# THIS FILES IS AUTOMATICALLY GENERATED BY {__file__}
# PLEASE DO NOT EDIT

from owlready2 import get_ontology
onto = get_ontology("file://{_owl_filename}").load()
"""

class OwlParseError(Exception): pass

def to_camel_case(snake_str):
    return "".join(x.capitalize() for x in snake_str.lower().split("_"))

def is_legal_python_name(name: str):
    if name[0].isalpha() and all(c.isalnum() or c == "_" for c in name[1:]):
        return True
    return False

def get_tag_content(lines: list[str], tag: str) -> list[list[str]]:
    """
    get chunks of lines for a specific tag

    :param lines: a list of lines, usually from an xml file
    :param tag: the tag name
    :return:
    """
    tag_start = f"<{tag}"
    tag_end = f"</{tag}>"
    tag_contents = []
    for i, line in enumerate(lines):
        if line.strip().startswith(tag_start):
            found_close = False
            for j in range(800):
                if lines[i + j].strip().endswith(tag_end):
                    found_close = True
                    break
            if not found_close:
                raise RuntimeError(f"cannot find closure for: {tag} at line: {i}")
            tag_content = lines[i: i + j + 1]
            tag_contents.append(tag_content)
    return tag_contents

def parse_thing_class(lines: list[str]):
    try:
        assert _owl_iri in lines[0]
    except AssertionError:
        raise OwlParseError(f"iri not found in the first line: {lines[0]}")
    iri = lines[0].strip().split('"')[1]
    assert _owl_iri in iri

    rdfs_label = get_tag_content(lines, _tag_rdfs_label)
    try:
        assert len(rdfs_label) == 1
        assert len(rdfs_label[0]) == 1
    except AssertionError:
        raise OwlParseError(f"zero or more than one rdfs label tag in: \n{''.join(lines)}")
    rdfs_label = rdfs_label[0][0]
    try:
        assert rdfs_label.count("<") == 2
        assert rdfs_label.count(">") == 2
    except AssertionError:
        raise OwlParseError(f"weird rdfs label entry: {rdfs_label}")
    rdfs_label = rdfs_label.split('>')[1].split('<')[0]

    skos_definition = get_tag_content(lines, _tag_skos_definition)
    if len(skos_definition) == 0:
        skos_definition = ""
    else:
        skos_definition = skos_definition[0][0]
        skos_definition = skos_definition.split('>')[1].split('<')[0]
    return rdfs_label, iri, skos_definition


def parse_owl() -> dict[str, tuple]:
    data = defaultdict(tuple)

    with open(_owl_filename, "r") as f:
        lines = f.readlines()

    for tag in [_tag_class, _tag_object_property]:
        line_blocks = get_tag_content(lines, tag)
        for lb in line_blocks:
            try:
                thing_class_name, iri, definition = parse_thing_class(lb)
            except OwlParseError:
                continue
            data[iri] = (thing_class_name, definition)
    return data


def export_python_class(onto: Ontology, definition: str, class_name: str, iri: str, suffix: str = ""):
    cls = onto.search_one(iri=iri)
    if suffix != "":
        suffix = "__" + suffix

    if isinstance(cls, ObjectPropertyClass):
        python_class_name = class_name.replace(" ", "_") + suffix
        python_class_name = python_class_name.strip().replace("(", "_").replace(")", "")
        python_class_name = python_class_name.replace("-", "_")
        rename_template = f"{python_class_name}.python_name = '{python_class_name}'"
    elif isinstance(cls, ThingClass):
        python_class_name = class_name.replace(" ", "_")
        python_class_name = to_camel_case(python_class_name) + suffix
        python_class_name = python_class_name.strip().replace("(", "_").replace(")", "")
        python_class_name = python_class_name.replace("-", "_")
        # `set_name` changes IRI!! do not use it (at least for now)
        # rename_template = f"# {python_class_name}.set_name({python_class_name}, '{python_class_name}')"
        rename_template = f"{python_class_name}.label.append('{python_class_name}')"
    else:
        raise TypeError
    # if "(" in python_class_name and ")" in python_class_name:
    #     python_class_name = remove_text_in_brackets(python_class_name).strip().strip("_")
    if not is_legal_python_name(python_class_name):
        raise TypeError
    template = f"""
{python_class_name} = onto.search_one(iri="{iri}")
{rename_template}
    """
#     template = f"""
# {python_class_name} = onto.search_one(iri="{iri}")
# {rename_template}
# {python_class_name}.isDefinedBy.append('{definition}')
#     """
    return template, python_class_name


def export_owlready2(onto: Ontology, data: dict[str, tuple], existing_iri=None, existing_onto_classes_names=None):
    if existing_iri is None:
        existing_iri = set()

    if existing_onto_classes_names is None:
        existing_onto_classes_names = set()

    block_code = []

    for iri in data:
        if iri in existing_iri:
            continue
        try:
            onto_class_name = data[iri][0]
        except KeyError:
            continue
        try:
            definition = data[iri][1]
        except KeyError:
            definition = "definition missing"

        if "#" in iri:
            suffix = iri.split("#")[-1]
        else:
            suffix = iri.split("/")[-1]

        if onto_class_name not in existing_onto_classes_names:
            suffix = ""
        try:
            s, python_class_name = export_python_class(onto, definition, onto_class_name, iri, suffix=suffix)
        except TypeError:
            continue
        existing_onto_classes_names.add(onto_class_name)
        existing_iri.add(iri)
        block_code.append(s)
    return block_code, existing_iri, existing_onto_classes_names


def owl_to_owlready2():
    ontology = get_ontology(_owl_filename).load()
    bundle = []

    owl_data = parse_owl()
    block_code, registered_iris, registered_onto_classes_names = export_owlready2(ontology, owl_data,)
    bundle += block_code
    bundle = sorted(bundle)
    bundle = "\n".join(bundle)
    bundle += "\n"
    bundle = _OWLREADY2_HEADER + bundle
    with open("soo.py", "w") as f:
        f.write(bundle)


if __name__ == '__main__':
    owl_to_owlready2()
