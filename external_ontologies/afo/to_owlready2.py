import glob
import os.path
import pathlib
import shutil
from collections import defaultdict

from owlready2 import Ontology, ObjectPropertyClass, ThingClass, onto_path, get_ontology
from pandas._typing import FilePath

_OWX_DUMP_FOLDER = os.path.abspath("owx_dump")
_OWX_AFO = os.path.join(_OWX_DUMP_FOLDER, "afo.owx")
_OWLREADY2_HEADER = f"""# THIS FILES IS AUTOMATICALLY GENERATED BY {__file__}
# PLEASE DO NOT EDIT

from owlready2 import get_ontology
onto = get_ontology("file://{_OWX_AFO}").load()
"""


def get_tag_content(lines: list[str], tag: str) -> list[list[str]]:
    """
    get chunks of lines for a specific tag

    :param lines: a list of lines, usually from an xml file
    :param tag: the tag name
    :return:
    """
    tag_start = f"<{tag}>"
    tag_end = f"</{tag}>"
    tag_contents = []
    for i, line in enumerate(lines):
        if line.strip().startswith(tag_start):
            found_close = False
            for j in range(800):
                if lines[i + j].strip().endswith(tag_end):
                    found_close = True
                    break
            if not found_close:
                raise RuntimeError(f"cannot find closure for: {tag} at line: {i}")
            tag_content = lines[i: i + j + 1]
            tag_contents.append(tag_content)
    return tag_contents


def parse_annotation_assertion_lines(lines: list[str]):
    content = lines[1: -1]
    pref_label = """<AnnotationProperty IRI="http://www.w3.org/2004/02/skos/core#prefLabel"/>"""
    definition = """<AnnotationProperty IRI="http://www.w3.org/2004/02/skos/core#definition"/>"""
    if content[0].strip() == pref_label:
        key = "pref_label"
    elif content[0].strip() == definition:
        key = "definition"
    else:
        raise ValueError
    iri = get_tag_content(content, tag="IRI")
    assert len(iri) == 1
    iri = iri[0][0]
    literal = get_tag_content(content, tag="Literal")
    assert len(literal) == 1
    literal = literal[0][0]

    iri = iri.strip().lstrip("<IRI>").rstrip("</IRI>")
    literal = literal.strip()[len("<Literal>"): -len("</Literal>")]
    return iri, key, literal


def parse_owx(filepath: FilePath):
    with open(filepath, "r") as f:
        lines = f.readlines()

    data = defaultdict(dict)
    list_of_annotation_assertion_lines = get_tag_content(lines, "AnnotationAssertion")
    for lines in list_of_annotation_assertion_lines:
        try:
            iri, key, literal = parse_annotation_assertion_lines(lines)
        except ValueError:
            # logger.warning(f"error in parsing annotation assertion:\n {lines}")
            continue
        data[iri][key] = literal
    return data


def to_camel_case(snake_str):
    return "".join(x.capitalize() for x in snake_str.lower().split("_"))


def is_legal_python_name(name: str):
    if all(c.isalpha() or c == "_" for c in name):
        return True
    return False


def export_python_class(onto: Ontology, definition: str, class_name: str, iri: str, suffix: str = ""):
    cls = onto.search_one(iri=iri)
    if suffix != "":
        suffix = "__" + suffix

    if isinstance(cls, ObjectPropertyClass):
        python_class_name = class_name.replace(" ", "_") + suffix
        python_class_name = python_class_name.strip().replace("(", "_").replace(")", "")
        rename_template = f"{python_class_name}.python_name = '{python_class_name}'"
    elif isinstance(cls, ThingClass):
        python_class_name = class_name.replace(" ", "_")
        python_class_name = to_camel_case(python_class_name) + suffix
        python_class_name = python_class_name.strip().replace("(", "_").replace(")", "")
        # `set_name` changes IRI!! do not use it (at least for now)
        rename_template = f"# {python_class_name}.set_name({python_class_name}, '{python_class_name}')"
    else:
        raise TypeError
    # if "(" in python_class_name and ")" in python_class_name:
    #     python_class_name = remove_text_in_brackets(python_class_name).strip().strip("_")
    if not is_legal_python_name(python_class_name):
        raise TypeError
    template = f"""
{python_class_name} = onto.search_one(iri="{iri}")
{rename_template}
# {definition}
    """
    return template, python_class_name


def export_owlready2(onto: Ontology, data: dict[str, dict], existing_iri=None, include_header=False):
    if include_header:
        owlready_code = _OWLREADY2_HEADER
    else:
        owlready_code = ""

    if existing_iri is None:
        existing_iri = set()
    registered_class_name = set()
    registered_iri = set()
    for iri in data:
        if iri in existing_iri:
            continue
        try:
            onto_class_name = data[iri]['pref_label']
        except KeyError:
            continue
        try:
            definition = data[iri]['definition']
        except KeyError:
            definition = "definition missing"

        if "#" in iri:
            suffix = iri.split("#")[-1]
        else:
            suffix = iri.split("/")[-1]

        if onto_class_name not in registered_class_name:
            suffix = ""
        try:
            s, python_class_name = export_python_class(onto, definition, onto_class_name, iri, suffix=suffix)
        except TypeError:
            continue
        registered_class_name.add(onto_class_name)
        registered_iri.add(iri)
        owlready_code += s
    return owlready_code, registered_iri.union(existing_iri)


def owx_to_owlready2(bundle_files=True):
    this_dir = os.path.dirname(__file__)
    dump_dir = os.path.join(this_dir, "owx_dump")
    output_dir = os.path.join(this_dir, "ontologies")
    onto_path.append(dump_dir)
    ontology = get_ontology(f"file://{dump_dir}/afo.owx").load()
    shutil.rmtree(output_dir, ignore_errors=True)
    pathlib.Path(output_dir).mkdir(exist_ok=True)
    import_strings = []
    registered_iris = set()
    if not bundle_files:
        for fn in glob.glob(f"{dump_dir}/*.owx"):
            basename = os.path.basename(fn)
            module_name = basename[:-4].replace("-", "_")
            owx_data = parse_owx(fn)
            code, registered_iris = export_owlready2(ontology, owx_data, existing_iri=registered_iris,
                                                     include_header=True)
            with open(f"{output_dir}/{module_name}.py", "w") as f:
                f.write(code)
            import_sting = f"from .{module_name} import *"
            import_strings.append(import_sting)
        with open(f"{output_dir}/__init__.py", "w") as f:
            f.write("\n".join(import_strings))
            f.write("\n")
    else:
        bundle = _OWLREADY2_HEADER
        for fn in glob.glob(f"{dump_dir}/*.owx"):
            owx_data = parse_owx(fn)
            code, registered_iris = export_owlready2(ontology, owx_data, existing_iri=registered_iris,
                                                     include_header=False)
            bundle += code
            bundle += "\n"
        with open(f"{output_dir}/__init__.py", "w") as f:
            f.write(bundle)


if __name__ == '__main__':
    owx_to_owlready2(True)
